#+TITLE: Music Theory Course for RMA
#+AUTHOR: Matt Hood

* Principles
- Guided self-discovery via interactivity
- Avoid teaching common practise harmony. Focus instead on jazz and pop. In the latter case, investigate cyclic chord progressions as discussed by 12tone, Neely, etc.

* Note picker that is able to illustrate the process of moving from continuous frequency space to discrete notes that work well together
**Why?** Sound is a wilderness of discordance and dissonance. The machinery of tuning, scales, chords is all about finding the 'good notes', the subset of dissonance that is consonance. This exercise gives the student an appreciation of the value of elementary music theory, by experiencing how bad things are without it. This will then be a source of motivation to continue learning.

** The 'inline-js' blocks :noexport:
Support for 'inline-js' may be added via evaluation of the following elisp:
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-src-lang-modes '("inline-js" . javascript))
(defvar org-babel-default-header-args:inline-js
  '((:results . "html")
    (:exports . "results")))
(defun org-babel-execute:inline-js (body _params)
  (format "<script type=\"text/javascript\">\n%s\n</script>" body))
#+END_SRC

#+RESULTS:
: org-babel-execute:inline-js

Source: https://www.reddit.com/r/orgmode/comments/5bi6ku/tip_for_exporting_javascript_source_block_to/

** Implementation

#+begin_export html
<script src="https://unpkg.com/tone@13.8.25/build/Tone.js"></script>

<script src="frequency-resolution-applet.js"></script>

<div id="applet">Test</div>
#+end_export

#+begin_src inline-js :exports both
  let parent = document.getElementById("applet");
  let fra = new FrequencyResolutionApplet(parent, 700, 500, "major scale");
  console.log("1");
#+end_src

*** Graphics
#+begin_src inline-js :exports none
      class MetricToFrequencyMapper {

          supportedTunings = ["continuous", "chromatic", "major scale", "major triad"];
          stops = {"continuous": 480,
                         "chromatic": 24,
                         "major scale": 14,
                   "major triad": 6};

          lowFreq = 440.0;
          highFreq = this.lowFreq * 4;

          // This situation smells
          chromaticMap = (function(stop) {
              return this.lowFreq * Math.pow(2, stop / 12);
          }).bind(this);

          linearMap = (function(stop) {
              let fraction = (stop / this.stops["continuous"])
              let range = this.highFreq - this.lowFreq;
              return (fraction * range) + this.lowFreq;
          }).bind(this);

          frequencyMappers =
                {"continuous": this.linearMap,
                 "chromatic": this.chromaticMap,
                 "major scale":
                 (function(stop) {
                     let degrees = [0, 2, 4, 5, 7, 9, 11, 12, 14, 16, 17, 19, 21, 23];
                     return this.chromaticMap(degrees[stop]);
                 }).bind(this),
                 "major triad":
                 (function(stop) {
                     let degrees = [0, 4, 7, 12, 16, 19];
                     return this.chromaticMap(degrees[stop]);
                 }).bind(this)};

          constructor(height, tuning) {

              this.height = height;

              if(this.supportedTunings.includes(tuning)) {
                  this.tuning = tuning;
              }
              else {
                  throw new TypeError("Undefined tuning")
              }

          }

          pixelToStop(pixel) {
              // Ascend from the bottom
              let level = this.height - pixel;
              let stopWidth = this.height / this.stops[this.tuning];
              let stop = Math.floor(level / stopWidth);
              return stop;
          }

          stopToHue(stop) {
              let frac = stop / this.stops[this.tuning];
              return 2 * frac * 360;
          }

          stopToFrequency(stop) {
              return this.frequencyMappers[this.tuning](stop);
          }

          pixelToHue(pixel) {
              return this.stopToHue(this.pixelToStop(pixel));
          }

          pixelToFrequency(pixel) {
              return this.stopToFrequency(this.pixelToStop(pixel));
          }

          snapPixelHeight(pixel) {
              let stops = this.stops[this.tuning];
              let halfHeight = this.height / stops / 2;
              let lowerHeight = Math.floor(pixel * (stops / this.height)) * (this.height / stops);
              let snapped = lowerHeight + halfHeight;
              return snapped;
          }


          toHSL(h, s, l) {
              return 'hsl(' + Math.round(h) + ',' + s + '%,' + l + '%)';
          }
      }

      // Set up some dummy instances for testing
      let cont = new MetricToFrequencyMapper(500, "continuous");
      let chrom = new MetricToFrequencyMapper(500, "chromatic");
      let scale = new MetricToFrequencyMapper(500, "major scale");
      let chord = new MetricToFrequencyMapper(500, "major triad");

      // Test colour output
      console.log(cont.toHSL(cont.pixelToHue(210), 100, 50));
      console.log(chrom.toHSL(chrom.pixelToHue(210), 100, 50));
      console.log(scale.toHSL(scale.pixelToHue(210), 100, 50));
      console.log(chord.toHSL(chord.pixelToHue(210), 100, 50));

      // Test frequency output
      console.log(cont.pixelToFrequency(210))
      console.log(chrom.pixelToFrequency(210));
      console.log(scale.pixelToFrequency(210));
      console.log(chord.pixelToFrequency(210));


    // Draw the canvas
    function drawBackground(ctx, mapper, width, height) {
        for(let i = 0; i < height; i++) {
            ctx.fillStyle = mapper.toHSL(mapper.pixelToHue(i), 80, 60);
            ctx.fillRect(0, i, width, i + 1);
        }
    }

    let canvasHeight = 500;
    let canvasWidth = 500;
    canvas = document.getElementById("notes");

    clear_button = document.getElementById("clear_button");
    ctx = canvas.getContext("2d");

    window.noteSequence = [];
    window.currentMapper = cont;

    drawBackground(ctx, window.currentMapper, canvasWidth, canvasHeight);


    // Draw a notehead, where x,y are the center co-ordinates
    function drawNotehead(ctx, x, y) {
        headChar = '\uD834\uDD58'
        headSizes = ctx.measureText(headChar);
        topX = x - Math.abs(headSizes.actualBoundingBoxLeft);
        topY = y - Math.abs(headSizes.actualBoundingBoxAscent) + 2;
        backupFont = ctx.font;
        ctx.font = '72px serif';
        ctx.fillStyle = 'hsl(0, 100%, 0%)'
        ctx.fillText(headChar, topX, topY);
        ctx.font = backupFont;
    }

    function addNote(f, t) {
        window.noteSequence.push({freq: f, time: t});
    }

    function clearNotes() {
        window.noteSequence = [];
    }

    function enterNote(x, y) {
        freq = window.currentMapper.pixelToFrequency(y);
        time = x;
        drawY = window.currentMapper.snapPixelHeight(y);
        drawX = x;

        addNote(freq, time);
        drawNotehead(ctx, drawX, drawY);
    }

    function handleClick(event) {
        let rect = canvas.getBoundingClientRect();
        let x = event.clientX - rect.left;
        let y = event.clientY - rect.top;

        enterNote(x, y);

        console.log(window.noteSequence);
    }

    function clearCanvas() {
        clearNotes();
        drawBackground(ctx, window.window.currentMapper, canvasWidth, canvasHeight);
    }

  // Canvas event handlers
  canvas.addEventListener("mousedown", handleClick);
  clear_button.onclick = clearCanvas;

  // Change note resolution
  continuous_button = document.getElementById("continuous_button");
  chromatic_button = document.getElementById("chromatic_button");
  scale_button = document.getElementById("scale_button");
  chord_button = document.getElementById("chord_button");

  function resolutionChanger(mapper) {
      return function() {
          window.currentMapper = mapper;
          clearCanvas();
      };
  }

  continuous_button.onclick = resolutionChanger(cont);
  chromatic_button.onclick = resolutionChanger(chrom);
  scale_button.onclick = resolutionChanger(scale);
  chord_button.onclick = resolutionChanger(chord);
#+end_src

*** Audio
#+begin_src inline-js :exports none

    play_button = document.getElementById("play_button");
    stop_button = document.getElementById("stop_button");

  const synth = new Tone.PolySynth();
  synth.connect(Tone.context.destination);


    function play() {
        let now = Tone.now();
        window.noteSequence.forEach(function(note) {
            synth.triggerAttackRelease(note.freq, 0.1, now + note.time / 100);
            console.log(note);
        });
    }

    play_button.onclick = play;
#+end_src




*** To-dos
**** DONE Use a polyphonic synth to address bugs in adjacent notes
**** TODO Refactor into a single component
**** TODO Adjust saturation brightness per mode.

